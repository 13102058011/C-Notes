本文将详细介绍C语言中的指针，什么是详细介绍，就是你能遇到的问题几乎在这里都能解决

什么

[TOC]

## 指针变量

### 1. 介绍

指针变量，指针变量，指针是一个变量，它存储着另一个变量的地址。任何变量在内存中都有一个内存地址。那么地址有什么用呢，存储另一个变量的地址能做什么呢？

内存就像一个宾馆，变量就像宾馆里面住着的一个美女，地址就像房号，通过房号你就可以找到美女....

所以通过地址就可以找到变量，得到变量的值。我们知道在函数中改变形参的值，而实参的值不会改变，但是通过地址就可以在函数中改变实参的值。



### 2. 地址是什么东东？

地址这么神奇，那他到底是什么呢？地址是一个无符号十六进制整数, 从0开始。怎么看地址呢？其实我们在之前学习scanf的时候就接触过地址了，如下

```c
int a;
scanf("%d",&a);
```

上述代码相信大家再熟悉不过了，其实在这里 &a 就是 a 的地址，&又称为 取地址符 ，scanf通过变量a的地址将键盘输入的值赋值给变量a。上面说了地址是一个**无符号十六进制整数**，那我们就可以通过printf看到他，地址的占位符是**%p**，有些小伙伴可能要问，既然是十六进制数，可以用%x吗？当然可以，怎么不可以，既然是整数，还也可以用%d，当然这都是不规范的。

```c
int a;
printf("a的地址为：%p\n", &a);
printf("a的地址为：%x\n", &a);
printf("a的地址为：%d\n", &a);
```

输出结果

```c
a的地址为：00AFFB88
a的地址为：affb88
a的地址为：11533192
```

可以看到，无论是哪一种输出，它们结果的值都是一样的。



### 3. 指针变量的定义

那怎么定义指针变量呢？指针变量定义语法  `变量类型* 变量名` 如下：

```c	
int* p;
int *p;
float* p;
double* p;
```

有些好奇的小伙伴可能就要问了，int* p; 和 int \*p; 有区别吗，答案是没有区别，\*号的的位置没有要求。*

int\* p;就定义了一个int型的指针变量，float\* p;就定义了一个float型的指针变量。我们会发现，指针变量也有不同的类型。指针变量指向的数据类型, 称为**基类型**，int型的指针变量只能指向 int 型的变量，美女的房号只能指向美女，还能指向油头大叔吗？



### 4. 指针变量的赋值与初始化

指针变量的赋值，就是赋给指针变量一个地址

```c
int a;
int *p1;
p1 = &a;		//赋值
int* p2 = &a;	//初始化
```



### 5. 连续定义

```c
int* p1, p2, p3;
```

上述代码，有些小伙伴可能认为一次定义了三个int型的指针变量，其实不然。这是一个很大的误区，乍一看int\*是一种类型，所以顺理成章定义了p1, p2, p3三个指针变量。这样是不对的，正确的形式如下

```c
int* p1, * p2, * p3;
```



### 6. 指针的类型

上面说到指针变量指向的数据类型, 称为**基类型**，我们说的指针的类型就是指针的基类型

* 无论指向什么类型，所有指针的大小都是一样的（4个字节），因为都是地址
* 但是指向不同类型的指针是不能直接互相赋值的
* 这是为了避免用错指针



### 7.空指针

我们通常对一个未初始化的指针变量赋予NULL值，当我们定义一个指针变量但还不知道它要指向哪里的时候，我们常常就给它赋一个NULL值。

```c
int *p = NULL;
```

被赋予NULL值的指针被称为**空指针**，

```c
//空指针是值为NULL的指针, 即无效指针，不可以直接使用
//空指针可以查看地址, 不可以进行赋值
//不同的编译器空指针的地址形式不同
```

那NULL值到底是什么呢？下面是C语言的原函数

```c
NULL  #define NULL ((void *)0)
```

你会发现NULL是一个宏定义，是一个`((void *)0)`，你可能会想(void *)是什么，之后会有关于(void *)的详细介绍，目前你只需要知道它可以表示任意类型，也就是说不同类型的指针变量都可以赋予NULL值

```c
double *p = NULL;
float *p = NULL;
····
```

此外我们还注意到，NULL是一个0值，我们也称为**0地址**，我们的内存中有0地址，但是0地址通常是个不能碰的地址，所以你的指针不应该具有0值，那为什么我们还给未初始化的指针赋予NULL值呢？正因为0地址通常不能碰，所以可以用0地址来表示特殊的事情：返回的指针是无效的。



### 8.指针的使用

前面说了半天到底怎么使用指针呢？怎么获得指针变量对应的值呢？我们通过**间接寻址运算符(*)**来访问指针变量指向的变量的值，这个过程称为指针的**解引用**

```c
int a = 10;
int *p = &a;
printf("a = %d\n", a);
printf("*p = %d\n", *p);
```

输出结果

```c
a = 10
*p = 10
```








	2.空指针
		1. NULL  #define NULL ((void *)0)
		2. 空指针是值为NULL的指针, 即无效指针
		3. 空指针可以查看地址, 不可以进行赋值
		4. 不同的编译器空指针的地址形式不同
	
	3.0地址
		·当然你的内存中有0地址，但是0地址通常是个不能碰的地址
		·所以你的指针不应该具有0值
		·因此可以用0地址来表示特殊的事情：
			·返回的指针是无效的
		·指针没有被真正初始化（先初始化为0）
		·NULL是一个预定定义的符号，表示0地址
		·有的编译器不愿意你用0来表示0地址
	
	4.指针的类型
		·无论指向什么类型，所有指针的大小都是一样的，因为都是地址
		·但是指向不同类型的指针是不能直接互相赋值的
		·这是为了避免用错指针
	
	5.指针的类型转换
		·void*表示不知道指向什么东西的指针
		·计算式与char*相同（但不相通）
		·指针也可以转换类型
		·int *p = &i;void *q = (void*)p; 
		·这并没有改变p所指的变量的类型，而是让后人用不同的
			眼光通过p看它所指的变量
		·我不再当你是int啦，我认为你就是个void
	
	6.用指针来做什么
		·需要传入较大的数据时用作参数
		·传入数组后对数组做操作
		·函数返回不止一个结果
		·需要函数修改不止一个变量的时候

---------------------------------------------------------------------------------------------------
## 指针与函数

### 1.函数指针

指向函数的指针, 存储函数的入口地址



### 2.指针函数

指针函数指针函数，顾名思义是一个返回值为指针的函数

```c
	2.语法
		fun_type (*pointer)(type parameter ...)

	3.示例
		main{
			int (*p)(int) = abs;
			printf("abs = %d\n",(*p)(-2));
			printf("abs = %d\n",p(-2));
		}
		int abs(int a) {
			return (a > 0) ? a : (-a);
		}

	4.解析
		1. 函数名代表函数的入口地址
		2. int (*p)(int) 也可以写成 int (*p)(int x) x写不写无所谓
		3. (*p)(-2) 和 p(-2) 两种使用方法

2.指针函数
	1.说明
		指针函数是一个函数, 返回值是一个指针
	c
	2.语法
		fun_type *pointer(type parameter ...)
		
```

---------------------------------------------------------------------------------------------------
## 字符串

​	1.输入输出
​		1.示例
​			char str[11];
​			scanf_s("%s", str,10);
​			printf("%s\n", str);
​			char ch = getchar();
​			printf("input:\n");
​			gets_s(str,10);
​			puts(str);

		2.说明
			1. scanf_s不能读取空格, 因为空格被scanf_s作为结束符
			2. scanf_s中制表符, 空格, 回车, 不会被输入, 都存在了缓冲区中
			3. 可以使用getchar() 或者 scanf_s(" ") 来清空缓冲区
	
	2.字符串常量
		1.示例
			printf("hello \
			world are you ok?\n");
			printf("hello world"
				" are you ok?\n");
	
			printf("str\t %p\n", "hello");
			printf("pstr\t %p\n",pstr);
			printf("pstr[0]\t %p\n",&pstr[0]);
			/*
				str      006C7CD0
				pstr     -006C7CD0
				pstr[0]    006C7CD0
			*/
	
		2.说明
			1. 使用 \ 可以使printf函数换行输出, 但是第二行必须顶格写, 因为缩进会被输出
			2. 使用两段 """" 字符串也可以换行处理, 不用顶格写
			3. 双引号引起来的都是字符串常量
			4. 老规矩, 不会有重复的字符串常量, 相同的字符串常量会指向同一个字符串常量
			5. 字符串常量的地址是它的首地址
	
	3.字符串数组
		1.定义
			#define STR_LEN 80
			char str[STR_LEN + 1];
	
		2.初始化
			char str[80] = { "China" };
			char str[80] = "China";
			char str[] = "china";
	
	4.字符指针
		1.使用
			char* psrt = "hello world";
			char* pstr;
			psrt = "hello world";
	
		2.说明
			1. 字符指针指向一个字符串常量的首地址, 字符指针只指向首地址
			2. 可以改变 pstr 的指向, 不能改变 pstr 指向的字符串的值
	
		3.注意事项
			char str[10] = "hello";
			str = "world" 	//不可更改, 实际上数组变量是const型指针, 不可指向 "world" 的地址
	
	5.向函数传递字符串
		可以使用 字符数组 或者 字符指针 作为函数参数
	
	6.从函数返回字符指针
		使用 字符指针 作为函数返回值类型
	
	7.缓冲区溢出
		1.fgets函数
			1.示例
				char input[8];
				fgets(input, sizeof(input), stdin)
				for(i=0; input[i]!='\n'; i++);
				input[i] = '\0';
	
			2.说明
				1. stdin 表示从键盘输入
				2. sizeof(input) 表示从缓冲区截取的数据大小
				3. 后两句是将末尾的 \n 换成 \0


​		
​		2.案例1
​			char a;
​			scanf("%d",&a);
​			类型不匹配会产生缓冲区溢出

---------------------------------------------------------------------------------------------------


### 常用字符串函数

#### 1. strcmp

比较两个字符串，返回比较结果，比较的是字符串中每个字符的ANSII值总和

函数原型

```c
int strcmp(const char*s1,const char *s2)
```

返回值

```c
0: 		s1 == s2
1: 		s1 > s2
-1: 	s1 < s2
```



#### 2.strlen

用来获取字符串的长度，不会把'\0'算入字符串长度，返回值为字符串长度

函数原型

```c
typedef unsigned int     size_t;
size_t strlen(const char *s);
```





---------------------------------------------------------------------------------------------------
## 指针的算数运算

### 1. 指针减指针

指针减指针的值是两个指针间的变量数

```c
int a[] = {0,1,2,3,4,5,6};
int *p = a;
int *p1 = &a[5];
printf("p1 - p = %d\n",p1 - p);
```

输出结果

```c
p1 - p = 6
```



### 2. 指针与整数运算

指针与整数相加减相当于数组的下标相加减

```c
int a[] = {0,1,2,3,4,5,6};
int *p = a;
printf("p+2 = %d", *(p+2)) //2
```

输出结果

```c
p+2 = 2
```



### 3.*p++

	·取出p所指的那个数据来，完事之后顺便把p移到下一个位置去
	·*的优先级虽然高，但是没有++高
	·常用于数组类的连续空间操作
	·在某些CPU上，这些可以直接被编译成一条汇编指令



### 4.指针比较


		·<,<=,==,>,>=,!=都可以对指针做
		·比较它们在内存中的地址
		·数组中的单元的地址肯定是线性递增的



### 5.指针加指针

有些小伙伴可能要问怎么没有指针加指针，哈哈，就是没有，C语言是不允许指针加指针的

---------------------------------------------------------------------------------------------------


## 指针与数组

​	1.指针数组
​		1.说明
​			1.顾名思义, 存放指针的数组
​			2.因为[]的优先级高于*, 所以数组名会先于[]相结合成数组, 再与 int* 类型结合

		2.示例
			int* arr[10];
			arr[0] = &a;
	
		3.字符指针数组用来存储字符串
			1.示例
				char* string[] = { "hello","world","yes" };
				printf("%s\n", string[1]);
	
			2.说明
				1. 字符串为字符串常量
				2. 指针数组中每一个元素都指向一个字符串常量
	
	2.数组指针
		1.说明
			1.指向一个数组的指针
	
		2.语法
			type (*pointer)[length]
	
		2.示例
			int a[4] = { 1,2,3,4 };
			int(*p)[4] = a;
			printf("*p = %d\n\n", **p);
			//这里 *p 的值等于 a
			//要想获得值需要二次解引用， 即 **p
	
	3.数组和指针的关系
		1.数组变量是特殊的指针
			1. int a[10];int*p=a;//无需用&取地址
			2. 但是数组单元表达的是变量，需要用&取地址
			3. a == &a[0]
	
		2.[]运算符可以对数组做，也可以对指针做
			1. p[0] <==> a[0]
			2. p[]是把p指向的地方当作一个数组
			3. int *p=&a;//*p ==p[0]
	
		3.*运算符可以对指针做，也可以对数组做
			1. *a == a[0]
		
		4.数组变量是const的指针，所以不能被赋值
			1. int a[] <==> int *const a = ...
			1. 数组名的指向不可以被修改
	
	4.指针与二维数组
		1.二维数组首地址分析
			1. int arr[2][3] 表示 2行 3列 数组
			2. arr 表示 第0行 的首地址， arr + i 表示第i行的首地址
			3. arr[i] 表示 第i行 第0列 的地址
			4. arr 和 arr[0] 的地址是相等的
	
		2.指向二维数组的行指针
			1.示例
				int arr[2][3] = { 0 };
				int(*p)[3] = arr;
	
			2.说明
				1. 将二维数组看成一维数组，有两个“int[3]型”元素
				2. 则行指针的基类型为“int[3]型”
				3. 不可省略 *p 的括号
				4. 可以通过 *(*(p + i) + j) 来获取二维数组中 第i行 第j列 的值
	
		3.指向二维数组的列指针
			1.示例
				int arr[2][3] = { 1,2,3,4,5,6 };
				int* p1 = arr;
	
			2.说明
				1. 将二维数组看作一维数组，相当于6个int类型的数据
				2. 通过 *(p1+i) 获取二维数组中的第i个元素的值

---------------------------------------------------------------------------------------------------
二级指针
	1.说明
		二级指针就是指向指针的指针，n级指针以此类推

	2.示例
		int a = 0;
		int* p1 = &a;
		int* p2 = &p1;
		int** p3 = &p1;
	
		char* name[] = { "hello","world","nihao" };
		char** p_name = name;
	
	3.注
		1. 虽然一级指针变量也可以指向一级指针，但他们的间接类型不同，会引起不必要的错误
		2. 二级指针用于字符指针数组时会得心应手，但一级指针不可用于字符指针数组
---------------------------------------------------------------------------------------------------
const
	1.指针是const
		·表示一旦得到了某个变量的地址，不能在指向其他变量
		·int* const q = &i;//q是const
		·*q = 26;//OK，i不是const
		·q++;    //ERROR，q是const

	2.所指是const
		·表示不能通过这个指针去修改那个变量（并不能使得那个变量成为const）
		·const int *p = &i;
		·i = 26;//OK
		·p = &j;//OK
		·*p = 26;//ERROR!(*p是const)
	
	3.比较
		const int* p1 = &i;
		int const* p1 = &i;
		int *const p1 = &i;
		·const在*前面通过指针不能修改
		·const在*后面指针不能被修改
	
	4.转换
		·总可以把一个非const的值换成const的
		void f(const int *x);
		int a = 15;
		f(&a);//OK
		·当要传递的参数类型比地址还大的时候，这是常用的手段：
		既能用较少的字节数传递给参数，又能避免函数对外面的
		变量的修改
	
	5.const数组
		·const int a = {1,2,3,4,5,6};
		·数组变量已经是const的指针了，这里的const
		表明数组的每个单元都是const int
		·所以必须通过初始化进行赋值
	
	6.保护数组值
		·因为把数组传入函数时传递的是地址，所以那个函数
		内部可以修改数组的值
		·为了保护数组不被函数破坏，可以设置参数为const
		·int sum(const int a[],int length);