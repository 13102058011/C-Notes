#include<stdio.h>
int function_1(int* p);
int function_2(int a, int b, int* result);
int function_3(int a[], int* b);
void function_4(const int arr[]);

/* 指针详解 */

int main()
{
	int array[10 + 10];                     //正确，因为在编译后10+10就会被传换成20，是一个常量
	int a[5] = {1,2,3,4,5};
	int result;
	int i = 10;
	int j = 20;
	int* p = &i;


	//左值之所以叫做左值
	//是因为出现在赋值号左边的不一定是变量，而是一个值，是一个表达式计算的结果
	//a[0]和*p都是运算得到的一个特殊的值，这个值可以接受一个值，所以叫做左值
	a[0] = 2;
	*p = 3;


	//指针应用场景
	//函数返回运算的状态，结果通过指针返回
	if (function_2(10, 0, &result) == 0)
		printf("result = %d\n", result);
	else
		printf("除数为0!\n");


	//指针的常见错误
	//定义了一个指针变量，还没有指向任何变量，不可以使用
	int* p_1;
	*p_1 = 10;
	//p_1没有得到地址值，不可以使用


	//实际上数组变量是const型指针
//      int b[5]; ==> int *const b;
//      b = a;          数组变量不可以被修改
	function_3(a, a);


	//指针是const
	//表示一旦得到了某个变量的地址，不能再指向其他变量
	int* const p_2 = &i;    //p_2是const
	*p_2 = 26;                              //OK
	p_2++;                                  //ERROR,指针的指向不能改变


	//所指是const
	//表示不能通过这个指针去修改那个变量（并不能使得那个变量成为const）
	const int* p_3 = &i;    //所指是const
//      int const* p_3 = &i;    //与上式相同
	*p_3 = 26;                              //ERROR,(*p_3是const)
	p_3++;                                  //OK
	p_3 = &j;                               //OK

	//const在*的前面表示，所指不能修改，const在*后面表示指向不能改变


	//const数组
	const int arr[5] = { 1,2,3,4,5 };
	//数组变量已经是const的指针了，这里的const表示数组的每个单元都是const
	//这样的数组必须通过初始化来进行赋值
	//可以通过此操作让函数不修改数组值
	function_4(arr);


	//链表之所以需要返回一个头指针，是因为当链表为空时，新建链表时需要返回头指针
	//如果链表已经存在，则不需要返回头指针
	return 0;
}

int function_1(int* p)
{
	printf("p = %p\n", p);
	printf("*p = %d\n", *p);
}

int function_2(int a, int b, int* result)
{
	if (b == 0)     return-1;
	*result = a / b;
	return 0;
}

int function_3(int a[],int *b)
{
	//数组传到函数里，其实传递的是数组的首地址
	//没有办法用sizeof来求出数组的总长度
	int length = sizeof(a) / sizeof(a[0]);

	//在函数里修改数组变量，会改变原来的值
	a[0] = 100;

	/*
		数组和指针很像
		int array[10] = {0};
		a[1]表示的就是自 a 数组首地址

	*/

	//[]可以对指针做
	b[0] = 1000;

	//*也可以对数组做
	//其实是改变a[0]的值
	*a = 20;
}

void function_4(const int arr[])
{
	arr[0] = 10;    //错误写法，const保护了数组里的值
}

---------------------------------------------------------------------------------------------------
案例1

	1.代码
		int x = 65;
		int y = 44;
		int* p = &x;
		printf("x = %d, y = %d, p = %p\n\n", x, y, p);
		y = (*p)++;
		printf("x = %d, y = %d, p = %p\n\n", x, y, p);
	
	2.输出
		x = 65, y = 44, p = 0019FAA4
		x = 66, y = 65, p = 0019FAA4
	
	3.说明
		1. y 先赋值 *p, 之后 (*p) 又自增, 而 p 不变
		2. 若将 y = (*p)++; 换成 y = *p++; 则输出如下
			x = 65, y = 44, p = 00EFF808
			x = 65, y = 65, p = 00EFF80C
		  此时 y = *p, 之后 p++, 指针地址自增
---------------------------------------------------------------------------------------------------
指针基础
	1.说明
		1. 地址是一个无符号整数, 从0开始
		2. 指针变量指向的数据类型, 称为基类型

	2.空指针
		1. NULL  #define NULL ((void *)0)
		2. 空指针是值为NULL的指针, 即无效指针
		3. 空指针可以查看地址, 不可以进行赋值
		4. 不同的编译器空指针的地址形式不同

	3.0地址
		·当然你的内存中有0地址，但是0地址通常是个不能碰的地址
		·所以你的指针不应该具有0值
		·因此可以用0地址来表示特殊的事情：
			·返回的指针是无效的
		·指针没有被真正初始化（先初始化为0）
		·NULL是一个预定定义的符号，表示0地址
		·有的编译器不愿意你用0来表示0地址

	4.指针的类型
		·无论指向什么类型，所有指针的大小都是一样的，因为都是地址
		·但是指向不同类型的指针是不能直接互相赋值的
		·这是为了避免用错指针

	5.指针的类型转换
		·void*表示不知道指向什么东西的指针
		·计算式与char*相同（但不相通）
		·指针也可以转换类型
		·int *p = &i;void *q = (void*)p; 
		·这并没有改变p所指的变量的类型，而是让后人用不同的
			眼光通过p看它所指的变量
		·我不再当你是int啦，我认为你就是个void

	6.用指针来做什么
		·需要传入较大的数据时用作参数
		·传入数组后对数组做操作
		·函数返回不止一个结果
		·需要函数修改不止一个变量的时候

--------------------------------------------------------------------------------------------------- 
指针与函数
	1.函数指针
		1.说明
			指向函数的指针, 存储函数的入口地址

		2.语法
			fun_type (*pointer)(type parameter ...)

		3.示例
			main{
				int (*p)(int) = abs;
				printf("abs = %d\n",(*p)(-2));
				printf("abs = %d\n",p(-2));
			}
			int abs(int a) {
				return (a > 0) ? a : (-a);
			}

		4.解析
			1. 函数名代表函数的入口地址
			2. int (*p)(int) 也可以写成 int (*p)(int x) x写不写无所谓
			3. (*p)(-2) 和 p(-2) 两种使用方法

	2.指针函数
		1.说明
			指针函数是一个函数, 返回值是一个指针
		
		2.语法
			fun_type *pointer(type parameter ...)

---------------------------------------------------------------------------------------------------
字符串
	1.输入输出
		1.示例
			char str[11];
			scanf_s("%s", str,10);
			printf("%s\n", str);
			char ch = getchar();
			printf("input:\n");
			gets_s(str,10);
			puts(str);

		2.说明
			1. scanf_s不能读取空格, 因为空格被scanf_s作为结束符
			2. scanf_s中制表符, 空格, 回车, 不会被输入, 都存在了缓冲区中
			3. 可以使用getchar() 或者 scanf_s(" ") 来清空缓冲区

	2.字符串常量
		1.示例
			printf("hello \
			world are you ok?\n");
			printf("hello world"
				" are you ok?\n");

			printf("str\t %p\n", "hello");
			printf("pstr\t %p\n",pstr);
			printf("pstr[0]\t %p\n",&pstr[0]);
			/*
				str      006C7CD0
				pstr     -006C7CD0
				pstr[0]    006C7CD0
			*/

		2.说明
			1. 使用 \ 可以使printf函数换行输出, 但是第二行必须顶格写, 因为缩进会被输出
			2. 使用两段 """" 字符串也可以换行处理, 不用顶格写
			3. 双引号引起来的都是字符串常量
			4. 老规矩, 不会有重复的字符串常量, 相同的字符串常量会指向同一个字符串常量
			5. 字符串常量的地址是它的首地址

	3.字符串数组
		1.定义
			#define STR_LEN 80
			char str[STR_LEN + 1];

		2.初始化
			char str[80] = { "China" };
			char str[80] = "China";
			char str[] = "china";

	4.字符指针
		1.使用
			char* psrt = "hello world";
			char* pstr;
			psrt = "hello world";

		2.说明
			1. 字符指针指向一个字符串常量的首地址, 字符指针只指向首地址
			2. 可以改变 pstr 的指向, 不能改变 pstr 指向的字符串的值

		3.注意事项
			char str[10] = "hello";
			str = "world" 	//不可更改, 实际上数组变量是const型指针, 不可指向 "world" 的地址

	5.向函数传递字符串
		可以使用 字符数组 或者 字符指针 作为函数参数

	6.从函数返回字符指针
		使用 字符指针 作为函数返回值类型

	7.缓冲区溢出
		1.fgets函数
			1.示例
				char input[8];
				fgets(input, sizeof(input), stdin)
				for(i=0; input[i]!='\n'; i++);
				input[i] = '\0';

			2.说明
				1. stdin 表示从键盘输入
				2. sizeof(input) 表示从缓冲区截取的数据大小
				3. 后两句是将末尾的 \n 换成 \0

		
		2.案例1
			char a;
			scanf("%d",&a);
			类型不匹配会产生缓冲区溢出

---------------------------------------------------------------------------------------------------
指针的算数运算
	1.指针减指针
		1.说明
			指针减指针的值是两个指针间的变量数

		2.示例
			int a[] = {0,1,2,3,4,5,6};
			int *p = a;
			int *p1 = &a[5];
			printf("p1 - p = %d\n",p1 - p);//6

	2.指针与整数运算
		1.说明
			指针与整数相加减相当于数组的下标相加减

		2.示例
			int a[] = {0,1,2,3,4,5,6};
			int *p = a;
			printf("p+2 = %d", *(p+2)) //2

	3.*p++
		·取出p所指的那个数据来，完事之后顺便把p移到下一个位置去
		·*的优先级虽然高，但是没有++高
		·常用于数组类的连续空间操作
		·在某些CPU上，这些可以直接被编译成一条汇编指令


	4.指针比较
		·<,<=,==,>,>=,!=都可以对指针做
		·比较它们在内存中的地址
		·数组中的单元的地址肯定是线性递增的
		
---------------------------------------------------------------------------------------------------
指针与数组
	1.指针数组
		1.说明
			1.顾名思义, 存放指针的数组
			2.因为[]的优先级高于*, 所以数组名会先于[]相结合成数组, 再与 int* 类型结合

		2.示例
			int* arr[10];
			arr[0] = &a;

		3.字符指针数组用来存储字符串
			1.示例
				char* string[] = { "hello","world","yes" };
				printf("%s\n", string[1]);

			2.说明
				1. 字符串为字符串常量
				2. 指针数组中每一个元素都指向一个字符串常量
	
	2.数组指针
		1.说明
			1.指向一个数组的指针

		2.语法
			type (*pointer)[length]

		2.示例
			int a[4] = { 1,2,3,4 };
			int(*p)[4] = a;
			printf("*p = %d\n\n", **p);
			//这里 *p 的值等于 a
			//要想获得值需要二次解引用， 即 **p

	3.数组和指针的关系
		1.数组变量是特殊的指针
			1. int a[10];int*p=a;//无需用&取地址
			2. 但是数组单元表达的是变量，需要用&取地址
			3. a == &a[0]

		2.[]运算符可以对数组做，也可以对指针做
			1. p[0] <==> a[0]
			2. p[]是把p指向的地方当作一个数组
			3. int *p=&a;//*p ==p[0]

		3.*运算符可以对指针做，也可以对数组做
			1. *a == a[0]
		
		4.数组变量是const的指针，所以不能被赋值
			1. int a[] <==> int *const a = ...
			1. 数组名的指向不可以被修改

	4.指针与二维数组
		1.二维数组首地址分析
			1. int arr[2][3] 表示 2行 3列 数组
			2. arr 表示 第0行 的首地址， arr + i 表示第i行的首地址
			3. arr[i] 表示 第i行 第0列 的地址
			4. arr 和 arr[0] 的地址是相等的

		2.指向二维数组的行指针
			1.示例
				int arr[2][3] = { 0 };
				int(*p)[3] = arr;

			2.说明
				1. 将二维数组看成一维数组，有两个“int[3]型”元素
				2. 则行指针的基类型为“int[3]型”
				3. 不可省略 *p 的括号
				4. 可以通过 *(*(p + i) + j) 来获取二维数组中 第i行 第j列 的值

		3.指向二维数组的列指针
			1.示例
				int arr[2][3] = { 1,2,3,4,5,6 };
				int* p1 = arr;

			2.说明
				1. 将二维数组看作一维数组，相当于6个int类型的数据
				2. 通过 *(p1+i) 获取二维数组中的第i个元素的值

---------------------------------------------------------------------------------------------------
const
	1.指针是const
		·表示一旦得到了某个变量的地址，不能在指向其他变量
		·int* const q = &i;//q是const
		·*q = 26;//OK，i不是const
		·q++;    //ERROR，q是const

	2.所指是const
		·表示不能通过这个指针去修改那个变量（并不能使得那个变量成为const）
		·const int *p = &i;
		·i = 26;//OK
		·p = &j;//OK
		·*p = 26;//ERROR!(*p是const)

	3.比较
		const int* p1 = &i;
		int const* p1 = &i;
		int *const p1 = &i;
		·const在*前面通过指针不能修改
		·const在*后面指针不能被修改

	4.转换
		·总可以把一个非const的值换成const的
		void f(const int *x);
		int a = 15;
		f(&a);//OK
		·当要传递的参数类型比地址还大的时候，这是常用的手段：
		既能用较少的字节数传递给参数，又能避免函数对外面的
		变量的修改
	
	5.const数组
		·const int a = {1,2,3,4,5,6};
		·数组变量已经是const的指针了，这里的const
		表明数组的每个单元都是const int
		·所以必须通过初始化进行赋值

	6.保护数组值
		·因为把数组传入函数时传递的是地址，所以那个函数
		内部可以修改数组的值
		·为了保护数组不被函数破坏，可以设置参数为const
		·int sum(const int a[],int length);

---------------------------------------------------------------------------------------------------
C语言细节知识
	1.函数细节
		1.void swap();
			系统默认有两个int参数
		
		2.void swap(void)
			没有任何参数

	2.命令行参数
		int main(int argc, char*argv[])
			argc			命令行参数的数量(包括程序名本身)
			argv			指向命令行参数的指针数组
			argv[0]  	 	 -为指向程序名的字符指针
			argv[1]~argv[argc-1]	为指向余下的命令行参数的字符指针

---------------------------------------------------------------------------------------------------
结构体

















