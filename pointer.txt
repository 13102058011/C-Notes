#include<stdio.h>
int function_1(int* p);
int function_2(int a, int b, int* result);
int function_3(int a[], int* b);
void function_4(const int arr[]);

/* 指针详解 */

int main()
{
        int array[10 + 10];                     //正确，因为在编译后10+10就会被传换成20，是一个常量
        int a[5] = {1,2,3,4,5};
        int result;
        int i = 10;
        int j = 20;
        int* p = &i;


        //左值之所以叫做左值
        //是因为出现在赋值号左边的不一定是变量，而是一个值，是一个表达式计算的结果
        //a[0]和*p都是运算得到的一个特殊的值，这个值可以接受一个值，所以叫做左值
        a[0] = 2;
        *p = 3;


        //指针应用场景
        //函数返回运算的状态，结果通过指针返回
        if (function_2(10, 0, &result) == 0)
                printf("result = %d\n", result);
        else
                printf("除数为0!\n");


        //指针的常见错误
        //定义了一个指针变量，还没有指向任何变量，不可以使用
        int* p_1;
        *p_1 = 10;
        //p_1没有得到地址值，不可以使用


        //实际上数组变量是const型指针
//      int b[5]; ==> int *const b;
//      b = a;          数组变量不可以被修改
        function_3(a, a);


        //指针是const
        //表示一旦得到了某个变量的地址，不能再指向其他变量
        int* const p_2 = &i;    //p_2是const
        *p_2 = 26;                              //OK
        p_2++;                                  //ERROR,指针的指向不能改变


        //所指是const
        //表示不能通过这个指针去修改那个变量（并不能使得那个变量成为const）
        const int* p_3 = &i;    //所指是const
//      int const* p_3 = &i;    //与上式相同
        *p_3 = 26;                              //ERROR,(*p_3是const)
        p_3++;                                  //OK
        p_3 = &j;                               //OK

        //const在*的前面表示，所指不能修改，const在*后面表示指向不能改变


        //const数组
        const int arr[5] = { 1,2,3,4,5 };
        //数组变量已经是const的指针了，这里的const表示数组的每个单元都是const
        //这样的数组必须通过初始化来进行赋值
        //可以通过此操作让函数不修改数组值
        function_4(arr);


        //链表之所以需要返回一个头指针，是因为当链表为空时，新建链表时需要返回头指针
        //如果链表已经存在，则不需要返回头指针
        return 0;
}

int function_1(int* p)
{
        printf("p = %p\n", p);
        printf("*p = %d\n", *p);
}

int function_2(int a, int b, int* result)
{
        if (b == 0)     return-1;
        *result = a / b;
        return 0;
}

int function_3(int a[],int *b)
{
        //数组传到函数里，其实传递的是数组的首地址
        //没有办法用sizeof来求出数组的总长度
        int length = sizeof(a) / sizeof(a[0]);

        //在函数里修改数组变量，会改变原来的值
        a[0] = 100;

        /*
                数组和指针很像
                int array[10] = {0};
                a[1]表示的就是自 a 数组首地址

        */

        //[]可以对指针做
        b[0] = 1000;

        //*也可以对数组做
        //其实是改变a[0]的值
        *a = 20;
}

void function_4(const int arr[])
{
        arr[0] = 10;    //错误写法，const保护了数组里的值
}

---------------------------------------------------------------------------------------------------
案例1

	1.代码
		int x = 65;
		int y = 44;
		int* p = &x;
		printf("x = %d, y = %d, p = %p\n\n", x, y, p);
		y = (*p)++;
		printf("x = %d, y = %d, p = %p\n\n", x, y, p);
	
	2.输出
		x = 65, y = 44, p = 0019FAA4
		x = 66, y = 65, p = 0019FAA4
	
	3.说明
		1. y 先赋值 *p, 之后 (*p) 又自增, 而 p 不变
		2. 若将 y = (*p)++; 换成 y = *p++; 则输出如下
			x = 65, y = 44, p = 00EFF808
			x = 65, y = 65, p = 00EFF80C
		  此时 y = *p, 之后 p++, 指针地址自增

--------------------------------------------------------------------------------------------------- 
指针数组
	1.说明
		1.顾名思义, 存放指针的数组
		2.因为[]的优先级高于*, 所以数组名会先于[]相结合成数组, 再与 int* 类型结合

	2.示例
		int* arr[10];
		arr[0] = &a;
数组指针
	1.说明
		1.指向一个数组的指针

	2.语法
		type (*pointer)[length]

	2.示例
		int (*arr)[10]
		//是一个指向10个整型的一维数组的指针

函数指针
	1.说明
		指向函数的指针, 存储函数的入口地址

	2.语法
		fun_type (*pointer)(type parameter ...)

	3.示例
		main{
			int (*p)(int) = abs;
			printf("abs = %d\n",(*p)(-2));
			printf("abs = %d\n",p(-2));
		}
		int abs(int a) {
			return (a > 0) ? a : (-a);
		}

	4.解析
		1. 函数名代表函数的入口地址
		2. int (*p)(int) 也可以写成 int (*p)(int x) x写不写无所谓
		3. (*p)(-2) 和 p(-2) 两种使用方法

指针函数
	1.说明
		指针函数是一个函数, 返回值是一个指针
	
	2.语法
		fun_type *pointer(type parameter ...)

---------------------------------------------------------------------------------------------------
指针基础
	1.说明
		1. 地址是一个无符号整数, 从0开始
		2. 指针变量指向的数据类型, 称为基类型

	2.空指针
		1. NULL  #define NULL ((void *)0)
		2. 空指针是值为NULL的指针, 即无效指针
		3. 空指针可以查看地址, 不可以进行赋值
		4. 不同的编译器空指针的地址形式不同

	3.




















